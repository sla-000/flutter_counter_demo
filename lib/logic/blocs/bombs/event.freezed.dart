// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$BombsEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Iterable<Bomb> bombs) setAll,
    required TResult Function(Bomb bomb) add,
    required TResult Function(Iterable<Object> bombs) removeAll,
    required TResult Function(double delta) update,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Iterable<Bomb> bombs)? setAll,
    TResult? Function(Bomb bomb)? add,
    TResult? Function(Iterable<Object> bombs)? removeAll,
    TResult? Function(double delta)? update,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Iterable<Bomb> bombs)? setAll,
    TResult Function(Bomb bomb)? add,
    TResult Function(Iterable<Object> bombs)? removeAll,
    TResult Function(double delta)? update,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BombsEventInit value) init,
    required TResult Function(BombsEventSetAll value) setAll,
    required TResult Function(BombsEventAdd value) add,
    required TResult Function(BombsEventRemoveAll value) removeAll,
    required TResult Function(BombsEventUpdate value) update,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BombsEventInit value)? init,
    TResult? Function(BombsEventSetAll value)? setAll,
    TResult? Function(BombsEventAdd value)? add,
    TResult? Function(BombsEventRemoveAll value)? removeAll,
    TResult? Function(BombsEventUpdate value)? update,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BombsEventInit value)? init,
    TResult Function(BombsEventSetAll value)? setAll,
    TResult Function(BombsEventAdd value)? add,
    TResult Function(BombsEventRemoveAll value)? removeAll,
    TResult Function(BombsEventUpdate value)? update,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BombsEventCopyWith<$Res> {
  factory $BombsEventCopyWith(
          BombsEvent value, $Res Function(BombsEvent) then) =
      _$BombsEventCopyWithImpl<$Res, BombsEvent>;
}

/// @nodoc
class _$BombsEventCopyWithImpl<$Res, $Val extends BombsEvent>
    implements $BombsEventCopyWith<$Res> {
  _$BombsEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$BombsEventInitCopyWith<$Res> {
  factory _$$BombsEventInitCopyWith(
          _$BombsEventInit value, $Res Function(_$BombsEventInit) then) =
      __$$BombsEventInitCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BombsEventInitCopyWithImpl<$Res>
    extends _$BombsEventCopyWithImpl<$Res, _$BombsEventInit>
    implements _$$BombsEventInitCopyWith<$Res> {
  __$$BombsEventInitCopyWithImpl(
      _$BombsEventInit _value, $Res Function(_$BombsEventInit) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BombsEventInit implements BombsEventInit {
  const _$BombsEventInit();

  @override
  String toString() {
    return 'BombsEvent.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BombsEventInit);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Iterable<Bomb> bombs) setAll,
    required TResult Function(Bomb bomb) add,
    required TResult Function(Iterable<Object> bombs) removeAll,
    required TResult Function(double delta) update,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Iterable<Bomb> bombs)? setAll,
    TResult? Function(Bomb bomb)? add,
    TResult? Function(Iterable<Object> bombs)? removeAll,
    TResult? Function(double delta)? update,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Iterable<Bomb> bombs)? setAll,
    TResult Function(Bomb bomb)? add,
    TResult Function(Iterable<Object> bombs)? removeAll,
    TResult Function(double delta)? update,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BombsEventInit value) init,
    required TResult Function(BombsEventSetAll value) setAll,
    required TResult Function(BombsEventAdd value) add,
    required TResult Function(BombsEventRemoveAll value) removeAll,
    required TResult Function(BombsEventUpdate value) update,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BombsEventInit value)? init,
    TResult? Function(BombsEventSetAll value)? setAll,
    TResult? Function(BombsEventAdd value)? add,
    TResult? Function(BombsEventRemoveAll value)? removeAll,
    TResult? Function(BombsEventUpdate value)? update,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BombsEventInit value)? init,
    TResult Function(BombsEventSetAll value)? setAll,
    TResult Function(BombsEventAdd value)? add,
    TResult Function(BombsEventRemoveAll value)? removeAll,
    TResult Function(BombsEventUpdate value)? update,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class BombsEventInit implements BombsEvent {
  const factory BombsEventInit() = _$BombsEventInit;
}

/// @nodoc
abstract class _$$BombsEventSetAllCopyWith<$Res> {
  factory _$$BombsEventSetAllCopyWith(
          _$BombsEventSetAll value, $Res Function(_$BombsEventSetAll) then) =
      __$$BombsEventSetAllCopyWithImpl<$Res>;
  @useResult
  $Res call({Iterable<Bomb> bombs});
}

/// @nodoc
class __$$BombsEventSetAllCopyWithImpl<$Res>
    extends _$BombsEventCopyWithImpl<$Res, _$BombsEventSetAll>
    implements _$$BombsEventSetAllCopyWith<$Res> {
  __$$BombsEventSetAllCopyWithImpl(
      _$BombsEventSetAll _value, $Res Function(_$BombsEventSetAll) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bombs = null,
  }) {
    return _then(_$BombsEventSetAll(
      null == bombs
          ? _value.bombs
          : bombs // ignore: cast_nullable_to_non_nullable
              as Iterable<Bomb>,
    ));
  }
}

/// @nodoc

class _$BombsEventSetAll implements BombsEventSetAll {
  const _$BombsEventSetAll(this.bombs);

  @override
  final Iterable<Bomb> bombs;

  @override
  String toString() {
    return 'BombsEvent.setAll(bombs: $bombs)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BombsEventSetAll &&
            const DeepCollectionEquality().equals(other.bombs, bombs));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(bombs));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BombsEventSetAllCopyWith<_$BombsEventSetAll> get copyWith =>
      __$$BombsEventSetAllCopyWithImpl<_$BombsEventSetAll>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Iterable<Bomb> bombs) setAll,
    required TResult Function(Bomb bomb) add,
    required TResult Function(Iterable<Object> bombs) removeAll,
    required TResult Function(double delta) update,
  }) {
    return setAll(bombs);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Iterable<Bomb> bombs)? setAll,
    TResult? Function(Bomb bomb)? add,
    TResult? Function(Iterable<Object> bombs)? removeAll,
    TResult? Function(double delta)? update,
  }) {
    return setAll?.call(bombs);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Iterable<Bomb> bombs)? setAll,
    TResult Function(Bomb bomb)? add,
    TResult Function(Iterable<Object> bombs)? removeAll,
    TResult Function(double delta)? update,
    required TResult orElse(),
  }) {
    if (setAll != null) {
      return setAll(bombs);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BombsEventInit value) init,
    required TResult Function(BombsEventSetAll value) setAll,
    required TResult Function(BombsEventAdd value) add,
    required TResult Function(BombsEventRemoveAll value) removeAll,
    required TResult Function(BombsEventUpdate value) update,
  }) {
    return setAll(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BombsEventInit value)? init,
    TResult? Function(BombsEventSetAll value)? setAll,
    TResult? Function(BombsEventAdd value)? add,
    TResult? Function(BombsEventRemoveAll value)? removeAll,
    TResult? Function(BombsEventUpdate value)? update,
  }) {
    return setAll?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BombsEventInit value)? init,
    TResult Function(BombsEventSetAll value)? setAll,
    TResult Function(BombsEventAdd value)? add,
    TResult Function(BombsEventRemoveAll value)? removeAll,
    TResult Function(BombsEventUpdate value)? update,
    required TResult orElse(),
  }) {
    if (setAll != null) {
      return setAll(this);
    }
    return orElse();
  }
}

abstract class BombsEventSetAll implements BombsEvent {
  const factory BombsEventSetAll(final Iterable<Bomb> bombs) =
      _$BombsEventSetAll;

  Iterable<Bomb> get bombs;
  @JsonKey(ignore: true)
  _$$BombsEventSetAllCopyWith<_$BombsEventSetAll> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BombsEventAddCopyWith<$Res> {
  factory _$$BombsEventAddCopyWith(
          _$BombsEventAdd value, $Res Function(_$BombsEventAdd) then) =
      __$$BombsEventAddCopyWithImpl<$Res>;
  @useResult
  $Res call({Bomb bomb});
}

/// @nodoc
class __$$BombsEventAddCopyWithImpl<$Res>
    extends _$BombsEventCopyWithImpl<$Res, _$BombsEventAdd>
    implements _$$BombsEventAddCopyWith<$Res> {
  __$$BombsEventAddCopyWithImpl(
      _$BombsEventAdd _value, $Res Function(_$BombsEventAdd) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bomb = null,
  }) {
    return _then(_$BombsEventAdd(
      null == bomb
          ? _value.bomb
          : bomb // ignore: cast_nullable_to_non_nullable
              as Bomb,
    ));
  }
}

/// @nodoc

class _$BombsEventAdd implements BombsEventAdd {
  const _$BombsEventAdd(this.bomb);

  @override
  final Bomb bomb;

  @override
  String toString() {
    return 'BombsEvent.add(bomb: $bomb)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BombsEventAdd &&
            (identical(other.bomb, bomb) || other.bomb == bomb));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bomb);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BombsEventAddCopyWith<_$BombsEventAdd> get copyWith =>
      __$$BombsEventAddCopyWithImpl<_$BombsEventAdd>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Iterable<Bomb> bombs) setAll,
    required TResult Function(Bomb bomb) add,
    required TResult Function(Iterable<Object> bombs) removeAll,
    required TResult Function(double delta) update,
  }) {
    return add(bomb);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Iterable<Bomb> bombs)? setAll,
    TResult? Function(Bomb bomb)? add,
    TResult? Function(Iterable<Object> bombs)? removeAll,
    TResult? Function(double delta)? update,
  }) {
    return add?.call(bomb);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Iterable<Bomb> bombs)? setAll,
    TResult Function(Bomb bomb)? add,
    TResult Function(Iterable<Object> bombs)? removeAll,
    TResult Function(double delta)? update,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(bomb);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BombsEventInit value) init,
    required TResult Function(BombsEventSetAll value) setAll,
    required TResult Function(BombsEventAdd value) add,
    required TResult Function(BombsEventRemoveAll value) removeAll,
    required TResult Function(BombsEventUpdate value) update,
  }) {
    return add(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BombsEventInit value)? init,
    TResult? Function(BombsEventSetAll value)? setAll,
    TResult? Function(BombsEventAdd value)? add,
    TResult? Function(BombsEventRemoveAll value)? removeAll,
    TResult? Function(BombsEventUpdate value)? update,
  }) {
    return add?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BombsEventInit value)? init,
    TResult Function(BombsEventSetAll value)? setAll,
    TResult Function(BombsEventAdd value)? add,
    TResult Function(BombsEventRemoveAll value)? removeAll,
    TResult Function(BombsEventUpdate value)? update,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(this);
    }
    return orElse();
  }
}

abstract class BombsEventAdd implements BombsEvent {
  const factory BombsEventAdd(final Bomb bomb) = _$BombsEventAdd;

  Bomb get bomb;
  @JsonKey(ignore: true)
  _$$BombsEventAddCopyWith<_$BombsEventAdd> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BombsEventRemoveAllCopyWith<$Res> {
  factory _$$BombsEventRemoveAllCopyWith(_$BombsEventRemoveAll value,
          $Res Function(_$BombsEventRemoveAll) then) =
      __$$BombsEventRemoveAllCopyWithImpl<$Res>;
  @useResult
  $Res call({Iterable<Object> bombs});
}

/// @nodoc
class __$$BombsEventRemoveAllCopyWithImpl<$Res>
    extends _$BombsEventCopyWithImpl<$Res, _$BombsEventRemoveAll>
    implements _$$BombsEventRemoveAllCopyWith<$Res> {
  __$$BombsEventRemoveAllCopyWithImpl(
      _$BombsEventRemoveAll _value, $Res Function(_$BombsEventRemoveAll) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bombs = null,
  }) {
    return _then(_$BombsEventRemoveAll(
      null == bombs
          ? _value.bombs
          : bombs // ignore: cast_nullable_to_non_nullable
              as Iterable<Object>,
    ));
  }
}

/// @nodoc

class _$BombsEventRemoveAll implements BombsEventRemoveAll {
  const _$BombsEventRemoveAll(this.bombs);

  @override
  final Iterable<Object> bombs;

  @override
  String toString() {
    return 'BombsEvent.removeAll(bombs: $bombs)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BombsEventRemoveAll &&
            const DeepCollectionEquality().equals(other.bombs, bombs));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(bombs));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BombsEventRemoveAllCopyWith<_$BombsEventRemoveAll> get copyWith =>
      __$$BombsEventRemoveAllCopyWithImpl<_$BombsEventRemoveAll>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Iterable<Bomb> bombs) setAll,
    required TResult Function(Bomb bomb) add,
    required TResult Function(Iterable<Object> bombs) removeAll,
    required TResult Function(double delta) update,
  }) {
    return removeAll(bombs);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Iterable<Bomb> bombs)? setAll,
    TResult? Function(Bomb bomb)? add,
    TResult? Function(Iterable<Object> bombs)? removeAll,
    TResult? Function(double delta)? update,
  }) {
    return removeAll?.call(bombs);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Iterable<Bomb> bombs)? setAll,
    TResult Function(Bomb bomb)? add,
    TResult Function(Iterable<Object> bombs)? removeAll,
    TResult Function(double delta)? update,
    required TResult orElse(),
  }) {
    if (removeAll != null) {
      return removeAll(bombs);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BombsEventInit value) init,
    required TResult Function(BombsEventSetAll value) setAll,
    required TResult Function(BombsEventAdd value) add,
    required TResult Function(BombsEventRemoveAll value) removeAll,
    required TResult Function(BombsEventUpdate value) update,
  }) {
    return removeAll(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BombsEventInit value)? init,
    TResult? Function(BombsEventSetAll value)? setAll,
    TResult? Function(BombsEventAdd value)? add,
    TResult? Function(BombsEventRemoveAll value)? removeAll,
    TResult? Function(BombsEventUpdate value)? update,
  }) {
    return removeAll?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BombsEventInit value)? init,
    TResult Function(BombsEventSetAll value)? setAll,
    TResult Function(BombsEventAdd value)? add,
    TResult Function(BombsEventRemoveAll value)? removeAll,
    TResult Function(BombsEventUpdate value)? update,
    required TResult orElse(),
  }) {
    if (removeAll != null) {
      return removeAll(this);
    }
    return orElse();
  }
}

abstract class BombsEventRemoveAll implements BombsEvent {
  const factory BombsEventRemoveAll(final Iterable<Object> bombs) =
      _$BombsEventRemoveAll;

  Iterable<Object> get bombs;
  @JsonKey(ignore: true)
  _$$BombsEventRemoveAllCopyWith<_$BombsEventRemoveAll> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BombsEventUpdateCopyWith<$Res> {
  factory _$$BombsEventUpdateCopyWith(
          _$BombsEventUpdate value, $Res Function(_$BombsEventUpdate) then) =
      __$$BombsEventUpdateCopyWithImpl<$Res>;
  @useResult
  $Res call({double delta});
}

/// @nodoc
class __$$BombsEventUpdateCopyWithImpl<$Res>
    extends _$BombsEventCopyWithImpl<$Res, _$BombsEventUpdate>
    implements _$$BombsEventUpdateCopyWith<$Res> {
  __$$BombsEventUpdateCopyWithImpl(
      _$BombsEventUpdate _value, $Res Function(_$BombsEventUpdate) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? delta = null,
  }) {
    return _then(_$BombsEventUpdate(
      null == delta
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$BombsEventUpdate implements BombsEventUpdate {
  const _$BombsEventUpdate(this.delta);

  @override
  final double delta;

  @override
  String toString() {
    return 'BombsEvent.update(delta: $delta)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BombsEventUpdate &&
            (identical(other.delta, delta) || other.delta == delta));
  }

  @override
  int get hashCode => Object.hash(runtimeType, delta);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BombsEventUpdateCopyWith<_$BombsEventUpdate> get copyWith =>
      __$$BombsEventUpdateCopyWithImpl<_$BombsEventUpdate>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Iterable<Bomb> bombs) setAll,
    required TResult Function(Bomb bomb) add,
    required TResult Function(Iterable<Object> bombs) removeAll,
    required TResult Function(double delta) update,
  }) {
    return update(delta);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Iterable<Bomb> bombs)? setAll,
    TResult? Function(Bomb bomb)? add,
    TResult? Function(Iterable<Object> bombs)? removeAll,
    TResult? Function(double delta)? update,
  }) {
    return update?.call(delta);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Iterable<Bomb> bombs)? setAll,
    TResult Function(Bomb bomb)? add,
    TResult Function(Iterable<Object> bombs)? removeAll,
    TResult Function(double delta)? update,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update(delta);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BombsEventInit value) init,
    required TResult Function(BombsEventSetAll value) setAll,
    required TResult Function(BombsEventAdd value) add,
    required TResult Function(BombsEventRemoveAll value) removeAll,
    required TResult Function(BombsEventUpdate value) update,
  }) {
    return update(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BombsEventInit value)? init,
    TResult? Function(BombsEventSetAll value)? setAll,
    TResult? Function(BombsEventAdd value)? add,
    TResult? Function(BombsEventRemoveAll value)? removeAll,
    TResult? Function(BombsEventUpdate value)? update,
  }) {
    return update?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BombsEventInit value)? init,
    TResult Function(BombsEventSetAll value)? setAll,
    TResult Function(BombsEventAdd value)? add,
    TResult Function(BombsEventRemoveAll value)? removeAll,
    TResult Function(BombsEventUpdate value)? update,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update(this);
    }
    return orElse();
  }
}

abstract class BombsEventUpdate implements BombsEvent {
  const factory BombsEventUpdate(final double delta) = _$BombsEventUpdate;

  double get delta;
  @JsonKey(ignore: true)
  _$$BombsEventUpdateCopyWith<_$BombsEventUpdate> get copyWith =>
      throw _privateConstructorUsedError;
}
